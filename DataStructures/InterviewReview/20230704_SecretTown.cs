//2023 07 04 시크릿 타운 면접 복습.



/*
 * 1. OOP 문법 중 C#에서의 다양화.
 * 2. C# 상속 중 Abstract, Virtual 의 차이점.
 * 3. 큐(FIFO), 스택(LIFO)를 사용하는 범위 및 차이.
 * 4. delegate와 interface 차이.
 * 5. 싱글톤과 전역변수의 차이.
 * 6. 트리 종류 정리 필요함.
 * 7. 가비지 컬렉터가 하는일.
 * 8. 렌더링 파이프라인.
 * 9. UGUI가 유니티에서 어떻게 실행되는지?
 * 10. 배치(Batch), 드로우콜(DrawCall)의 차이.
 */

/*
 * 1. OOP 문법
 * - 1. 추상화(Abstraction)
 * - 공통의 속성이나 기능을 묶어 이름을 붙이는 것.
 * - 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있겠다.
 *
 * - 2. 캡슐화(Encapsulation)
 * - 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것. 변수와 함수를 하나로 묶는것을 말한다.
 * - 무작정 한군데 묶으면 되는 것이 아니라 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다 라고 생각해야한다.(은닉화)
 * - 데이터를 절대로 외부에서 직접접근을 하면 안되고 오로지 함수를 통해서만 접근해야하는데 이를 가능하게 하는게 캡슐화다.
 * - 캡슐화에 성공하면 당연히 은닉화도 자연스럽게 효력이 나타난다.
 *
 * - 3. 상속성, 재사용(Inheritance)
 * - 상위 개념의 특징을 하위 개념이 물려받는 것
 * - 객체지향의 하이라이트 부분이라고 생각한다. 상속이란 개념이 없으면 객체지향이나 절차지향이나 그게그거다.
 * 
 * - 4. 다형성(Polymorphism)
 * - 부모 클래스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용 되는것.
 * 
 */

/*
 * 2. C# 상속 중 Abstract, Virtual, Interface.
 * - 1. Virtual(가상 키워드)
 * - virtual 키워드는 메서드, 속성, 인덱서 또는 이벤트 선언을 한정하는데 사용됩니다.
 * - 파생 클래스에서 필요에 따라서 재정의(override) 할 수있지만 필수적으로 재정의 할 필요는 없다.
 * - Virtual 한정자를 사용한 클래스는 완벽한 기능을 제공할 수 있습니다.
 *  public class Animal
    {
        public virtual void Speak()
        {
            Console.WriteLine("Nothing!");
        }
    }
 
    public class Dog : Animal
    {
        public override void Speak()
        {
            Console.WriteLine("멍멍!");
        }
    }
 
    Dog temp = new Dog();
    temp.Speak();//멍멍!
 * 
 * 
 * - 2. Abstract(추상화)
 * - abstact 키워드를 사용하면 불완전하여 파생클래스에서 구현해야하는 클래스 및 클래스 멤버를 만들수있다.
 * - 추상 클래스의 사용 목적은 여러개의 파생 클래스에서 공유할 기본 클래스의 공통적인 정의를 제공하는 것입니다.
 * - 추상 클래스는 인스턴스화 할 수 없다.
 * 
 *  public abstract class Animal
    {
        public abstract void Speak();
    }
 
    public class Dog : Animal
    {
        public override void Speak()
        {
            Console.WriteLine("멍멍!");
        }
    }
 
    Dog temp = new Dog();
    temp.Speak();//멍멍!

 * - 3. Interface(인터페이스)
 * - 인터페이스는 abstract와 비슷하지만 멤버필드(변수) 를 사용할 수 없습니다. 대신 프로퍼티는 사용이 가능합니다.
 * - 인터페이스는 보통 여러클래스에 공통적인 기능을 추가하기위해 사용합니다.
 *  public interface Animal
    {
        void Speak();
 
        string Name
        {
            get;
            set;
        }
    }
 
    class Dog : Animal
    {
        private string name;
     
        public void Speak()
        {
            Console.WriteLine(name + "->멍멍!");
        }
     
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }
    }
     
    Dog temp = new Dog();
    temp.Name = "흰둥이";
    temp.Speak(); //흰둥이->멍멍!
 * 
 * 결론====
 * - Virtual은 하나의 기능을 하는 완전한 클래스다.
 * 파생클래스에서 상속해서 추가적인 기능추가 및 virtual 한정자가 달린 것을 재정의해서 사용가능하다.
 * 
 * - Abstract는 여러개의 파생 클래스에서 공유할 기본 클래스의 공통적인 정의만 하고,
 * 파생클래스에서 abstract 한정자가 달린 것을 모두 재정의(필수)해야 합니다.
 * 
 * - Interface에서도 abstract와 비슷하지만 멤버변수를 사용할 수 없습니다.
 * 보통 abstract는 개념적으로 계층적인 구조에서 사용이 되며(동물이나 어떤 사물의 계층적인 구조가있을때)
 * Interface는 서로다른 계층이나 타입이라도 같은 기능을 추가하고 싶을때 사용합니다.
 * (사람이나 기계가 말을하게(speak)하는 인터페이스를 추가할때)

 */

/*
 * 3. 큐(FIFO), 스택(LIFO)를 사용하는 범위 및 차이.
 * - 1. 스택(Stack)이란?
 * - Last in First Out의 구조로 입력한 데이터가 가장 위에 쌓이고.
 * 가장 위에서 데이터를 가져가는 방식이다.
 * 활용 방식 : 
 * 웹 브라우저 방문기록 : 뒤로가기
 * 역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력된다.
 * 실행 취소(Undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
 * 후위 표기법 계산
 * 수식의 괄호 검사(연산자 우선순위 표현을 위한 괄호 검사)
 * 
 * - 2. 큐(Queue) 란?
 * - First in First Out의 구조로 입력한 데이터가 순서대로 쌓이고
 * 가장 처음 입력된 데이터를 가져가는 방식이다.
 * 활용방식 : 
 * 우선 순위가 같은 작업 예약(프린터의 인쇄 대기열)
 * 은행 업무
 * 콜센터 고객 대기시간
 * 프로세스 관리
 * 너비 우선 탐색(BFS, Breadth - First Search) 구현
 * 캐시(Cache) 구현
 */

/*
 * 4. delegate와 interface 차이.
 * 
 * 인터페이스 : 
 * - 메소드의 목록만을 가지는 특별한 타입
 * - 멤버들은 구현코드들을 가지지않는다.
 * - 본체가 없고 동작이 정의되어있지 않기때문에 직접 호출할 수 없는 추상메소드
 * - 메소드를 물려주는 역할
 * - 계약, 약속 : 메소드의 구현을 강제한다.
 * - 인터페이스로부터 상속을 받는 클래스들은 인터페이스에 포함된 모든 메소드를 구현해야한다.
 * 
 * 델리게이트 : 
 * - 메소드를 가리키는 참조형으로서 메소드의 번지를 저장하거나 다른 메소드의 인수로 메소드 자체를 전달하고싶을때 사용
 * - C++의 함수 포인터에 대응되는 타입.
 * 
 * 
 */

/*
 * 5. 싱글톤과 전역변수의 차이.
 */

/*
 * 6. 트리 종류 정리 필요함.
 */

/*
 * 7. 가비지 컬렉터가 하는일.
 */

/*
 * 8. 렌더링 파이프라인.
 * 로컬스페이스 -> 월드스페이스 -> 뷰 스페이스 -> 후면 추려내기(Backface Culling) -> 조명 -> 클리핑 -> 투영 -> 뷰포트 -> 래스터라이즈
 * 
 * 로컬스페이스 : 모델링 스페이스라고도 불림, 물체의 삼각형 리스트를 정의하는데 이용하는 좌표 시스템.
 * 
 * 월드스페이스 : 자체의 로컬 좌표 시스템 내에 다수의 모델을 구성한 다음에는 이를 전역(월드)좌표 시스템으로 옮겨 하나의 장면을 구성해야한다.
 * 로컬 스페이스의 물체들은 이동, 회전, 크기 변형 등을 포함하는 월드 변환이라는 작업을 거쳐 월드 스페이스로 옮겨진다.
 * 월드 변환은 위치와 크기, 방위를 포함하는 각 물체 간의 관계를 정의함으로써 이루어진다.
 * 
 * 뷰 스페이스 : 월드 스페이스 내에서 기하물체와 카메라는 월드 좌표 시스템과 연계되어 정의된다.
 * 한편, 카메라가 월드 내 임의의 위치나 방위를 가진다면 투영이나 그밖에 작업이 어렵거나 덜 효율적이 된다.
 * 따라서 작업의 수월함을 위해 카메라를 월드 시스템의 원점으로 변환하고, 카메라에 맞추어 월드 내의 모든 기하물체를 변환해야하는데, 이와 같은 변환을
 * 뷰스페이스 변환이라 하며, 이변환을 거친 뒤의 기하물체는 뷰스페이스 내에 위치한다고 말할 수 있다.
 * 
 * 후면 추려내기 : 폴리곤은 두개의 면을 가지고있으며 하나의 면을 전면, 다른면을 후면이라 부른다.
 * 일반적으로 폴리곤의 후면은 절대 보여지지 않는데, 이는 장면 내의 물체들이 내부로 카메라를 넣는 것이 혀용되지 않기 때문이다.
 * 카메라는 절대로 폴리곤의 후면을 보지 못한다. 이와 같은 사실은 매우 중요한데, 폴리곤의 후면을 볼 수 있는 경우에는 후면 추려내기가 작동하지 않기 때문이다.
 * 
 * 조명 : 광원은 월드 스페이스 내에 정의되지만 뷰 스페이스 변환에 의해 뷰 스페이스로 변환된다.
 * 광원은 물체에 명암을 추가하여 장면에 사실감을 더해준다.
 * 
 * 클리핑 : 시야 볼륨 외부의 기하물체를 추려내야한다. 이과정을 클리핑이라 한다.
 * 시야 철두체에서의 삼각형 위치는 다음과 같이 세 가지도 분류 할 수 있다.
 * 1. 완전한 내부 -> 삼각형이 완전히 절두체 내부에 위치하면 그대로 보존되어 다음 단계로 진행한다. 
 * 2. 완전한 외부 -> 삼각형이 완전히 절두체 외부에 위치하면 추려내어진다.
 * 3. 부분적 내부(부분적 외부) -> 삼각형이 부분적으로 절두체 내부에 위치하면 삼각형을 두 개의 부분으로 분리한다. 절두체 내부의 부분은 보존되며, 나머지는 추려내어진다.
 * 
 * 투영 : 뷰 스페이스에서는 3D 장면의 2D 표현을 얻는 과정이 남아있다. 이와 같이 n차원에서 n-1차원을 얻는 과정을 투영(Projection)이라 한다.
 * 투영은 여러가지 방법이 있지만 원근 투영(Perspective Projection)이라는 방법으로, 원근법을 이용하여 기하물체를 투사한다.
 * 즉, 카메라에서 멀리 떨어진 물체는 가까운 물체에 비해 작게 나타난다. 이와 같은 타입의 투영은 3D장면을 2D 이미지로 표현하는 데 가장 적합 하다.
 * 
 * 뷰표트 변환 : 뷰포트 변환은 프로젝트 윈도으의 좌표를 부표트라 불리는 화면의 직사각형으로 변환하는 과정을 말한다.
 * 게임에서의 뷰포트는 보통 직사각형으 ㅣ전체 화면이 되지만, 윈도우 모드에서 실행하는 경우에는 클라이언트 영역이나 화면의 일부가 될 수도 있다.
 * 뷰포트사각형은 이를 포함하고 있는 윈도우와 상대적이며, 윈도우 좌표를 이용해 지정된다.
 * 
 * 래스터라이즈 : 스크린 좌표로 버텍스들을 변환한 다음에는 2D 삼각형들의 리스트를 가지게된다.
 * 래스터라이즈 단계는 각각의 삼각형을 그리는데 필요한 픽셀 컬러들을 계산하는 과정이다.
 * 래스터라이즈 과정은 엄청난 작업 양을 필요로 하므로 반드시 전용 그래픽 하드웨어에서 처리되야 한다.
 * 래스터라이즈의 결과물은 모니터에 바로 디스플레이 할수 있는 2D 이미지가 된다.
 * 
 * 요약 - 
 * - 3D 물체들은 물체의 모양과 외각을 묘사하는 삼각형들의 리스트인 삼각형 메쉬들로 표현된다.
 * - 가상 카메라는 절두체로 모델링되며 절두체 내의 공간이 카메라가 "보는" 것이 된다.
 * - 3D 물체들은 로컬스페이스 내에 정의되며 모두 하나의 월드 스페이스 시스템으로 옮겨진다.
 * 투영을 위해서는 추려내기와 같은 다른작업이 필요하며, 뷰스페이로 물체를 변환하고 카레마를 원점으로 옮기고 양의 z축을 내려다 보도록 하는 과정이 진행된다.
 * 뷰 스페이스 내에 놓여진 물체들은 투영 윈도우로 투영되며, 뷰포트 변환을 통해 투영 윈도우의 기하물체가 뷰포트로 변환된다. 
 * 이제 최정적으로 래스터라이즈를 거쳐 최종 2D 이미지를 구성하는 각각의 픽셀 컬러가 계산된다.
 * 
 */

/*
 * 9. UGUI가 유니티에서 어떻게 실행되는지?
 * 
 * UGUI는 built-in으로 탑재된 GameObject 기반의 UI관련 패키지이다.
 * GameObject기반이니 당연히 컴포넌트 기반으로 동작한다.
 * 제공되는 각기 다른 특성을 지닌 컴포넌트를 사용해 Canvas게임오브젝트 아래에 자식 UI게임오브젝트들을 구성하면
 * Canvas 게임오브젝트는 자식까지 포함해 C++엔진과 연동해서 UI로 각 프레임에 그려준다.
 * (C++로 작성된 핵심 컴포넌트는 Canvas, RectTransform, CanvasRenderer, CanvasGroup가 있다.)
 */

/*
 * 10. 배치(Batch), 드로우콜(DrawCall)의 차이.
 * - 1. 드로우콜(DrawCall)
 * 그리기 요청, cpu가 gpu 에게 그려달라고 요청 하는 것.
 * 
 * - 2. 배칭(Batching)
 * 배칭이란 동일한 메터리얼을 공유하는 오브젝트들을 묶어서 드로우콜 하는 기법이다.
 * 동일한 메터리얼을 공유하는 오브젝트만 배칭할 수 있다.
 * 
 */